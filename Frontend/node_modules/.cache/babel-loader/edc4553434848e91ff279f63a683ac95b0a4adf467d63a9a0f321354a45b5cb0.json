{"ast":null,"code":"import { Response } from \"miragejs\";\nimport { formatDate, requiresAuth } from \"../utils/authUtils\";\nimport { v4 as uuid } from \"uuid\";\n/**\r\n * All the routes related to Address are present here.\r\n * These are private routes.\r\n * Client needs to add \"authorization\" header with JWT token in it to access it.\r\n * */\n\n/**\r\n * This handler handles getting all addresses from user.\r\n * send GET Request at /api/user/addresses\r\n * */\n\nexport const getAllAddressesHandler = function (schema, request) {\n  const userId = requiresAuth.call(this, request);\n  if (!userId) {\n    new Response(404, {}, {\n      errors: [\"The email you entered is not Registered. Not Found error\"]\n    });\n  }\n  const userAddresses = schema.users.findBy({\n    _id: userId\n  }).address;\n  return new Response(200, {}, {\n    address: userAddresses\n  });\n};\n\n/**\r\n * This handler handles adding an address to user.\r\n * send POST Request at /api/user/address\r\n * body contains { address }\r\n * */\n\nexport const addNewAddressHandler = function (schema, request) {\n  const userId = requiresAuth.call(this, request);\n  try {\n    if (!userId) {\n      new Response(404, {}, {\n        errors: [\"The email you entered is not Registered. Not Found error\"]\n      });\n    }\n    const userAddresses = schema.users.findBy({\n      _id: userId\n    }).address;\n    const {\n      address\n    } = JSON.parse(request.requestBody);\n    userAddresses.push({\n      ...address,\n      createdAt: formatDate(),\n      updatedAt: formatDate(),\n      _id: uuid()\n    });\n    this.db.users.update({\n      _id: userId\n    }, {\n      address: userAddresses\n    });\n    return new Response(201, {}, {\n      address: userAddresses\n    });\n  } catch (error) {\n    return new Response(500, {}, {\n      error\n    });\n  }\n};\n\n/** \r\n * This handler handles adding an address to user.\r\n * send POST request at api/user/address/:addressId\r\n * body contains { address }\r\n*/\n\nexport const editAddressHandler = function (schema, request) {\n  const userId = requiresAuth.call(this, request);\n  try {\n    if (!userId) {\n      new Response(404, {}, {\n        errors: [\"The email you entered is not Registered. Not Found error\"]\n      });\n    }\n    const addressId = request.params.addressId;\n    const {\n      address\n    } = JSON.parse(request.requestBody);\n    let userAddresses = schema.users.findBy({\n      _id: userId\n    }).address;\n    userAddresses = userAddresses.map(item => item._id === addressId ? address : item);\n    this.db.users.update({\n      _id: userId\n    }, {\n      address: userAddresses\n    });\n    return new Response(201, {}, {\n      address: userAddresses\n    });\n  } catch (error) {\n    return new Response(500, {}, {\n      error\n    });\n  }\n};\n\n/**\r\n * This handler handles removing an address from user.\r\n * send DELETE Request at /api/user/address/:addressId\r\n *\r\n * */\n\nexport const removeAddressHandler = function (schema, request) {\n  const userId = requiresAuth.call(this, request);\n  try {\n    if (!userId) {\n      new Response(404, {}, {\n        errors: [\"The email you entered is not Registered. Not Found error\"]\n      });\n    }\n    let userAddresses = schema.users.findBy({\n      _id: userId\n    }).address;\n    const addressId = request.params.addressId;\n    userAddresses = userAddresses.filter(item => item._id !== addressId);\n    this.db.users.update({\n      _id: userId\n    }, {\n      address: userAddresses\n    });\n    return new Response(200, {}, {\n      address: userAddresses\n    });\n  } catch (error) {\n    return new Response(500, {}, {\n      error\n    });\n  }\n};","map":{"version":3,"names":["Response","formatDate","requiresAuth","v4","uuid","getAllAddressesHandler","schema","request","userId","call","errors","userAddresses","users","findBy","_id","address","addNewAddressHandler","JSON","parse","requestBody","push","createdAt","updatedAt","db","update","error","editAddressHandler","addressId","params","map","item","removeAddressHandler","filter"],"sources":["C:/Users/Shiro/Desktop/ecommerce-attire/src/backend/controllers/AddressController.js"],"sourcesContent":["import { Response } from \"miragejs\";\r\nimport { formatDate, requiresAuth } from \"../utils/authUtils\";\r\nimport { v4 as uuid } from \"uuid\";\r\n/**\r\n * All the routes related to Address are present here.\r\n * These are private routes.\r\n * Client needs to add \"authorization\" header with JWT token in it to access it.\r\n * */\r\n\r\n/**\r\n * This handler handles getting all addresses from user.\r\n * send GET Request at /api/user/addresses\r\n * */\r\n\r\nexport const getAllAddressesHandler = function (schema, request) {\r\n  const userId = requiresAuth.call(this, request);\r\n  if (!userId) {\r\n    new Response(\r\n      404,\r\n      {},\r\n      {\r\n        errors: [\"The email you entered is not Registered. Not Found error\"],\r\n      }\r\n    );\r\n  }\r\n  const userAddresses = schema.users.findBy({ _id: userId }).address;\r\n  return new Response(200, {}, { address: userAddresses });\r\n};\r\n\r\n/**\r\n * This handler handles adding an address to user.\r\n * send POST Request at /api/user/address\r\n * body contains { address }\r\n * */\r\n\r\nexport const addNewAddressHandler = function (schema, request) {\r\n  const userId = requiresAuth.call(this, request);\r\n  try {\r\n    if (!userId) {\r\n      new Response(\r\n        404,\r\n        {},\r\n        {\r\n          errors: [\"The email you entered is not Registered. Not Found error\"],\r\n        }\r\n      );\r\n    }\r\n    const userAddresses = schema.users.findBy({ _id: userId }).address;\r\n    const { address } = JSON.parse(request.requestBody);\r\n\r\n    userAddresses.push({\r\n      ...address,\r\n      createdAt: formatDate(),\r\n      updatedAt: formatDate(),\r\n      _id: uuid(),\r\n    });\r\n    this.db.users.update({ _id: userId }, { address: userAddresses });\r\n    return new Response(201, {}, { address: userAddresses });\r\n  } catch (error) {\r\n    return new Response(\r\n      500,\r\n      {},\r\n      {\r\n        error,\r\n      }\r\n    );\r\n  }\r\n};\r\n\r\n/** \r\n * This handler handles adding an address to user.\r\n * send POST request at api/user/address/:addressId\r\n * body contains { address }\r\n*/\r\n\r\nexport const editAddressHandler = function (schema, request) {\r\n  const userId = requiresAuth.call(this, request);\r\n\r\n    try {\r\n        if(!userId){\r\n            new Response(\r\n                404,\r\n                {},\r\n                {\r\n                    errors: [\"The email you entered is not Registered. Not Found error\"],\r\n                }\r\n            );\r\n        }\r\n\r\n        const addressId = request.params.addressId;\r\n        const {address} = JSON.parse(request.requestBody);\r\n\r\n        let userAddresses = schema.users.findBy({_id: userId}).address;\r\n\r\n        userAddresses =  userAddresses.map((item)=>\r\n            item._id === addressId ? address : item\r\n        );\r\n\r\n        this.db.users.update({_id: userId}, {address: userAddresses});\r\n        return new Response(201, {}, {address: userAddresses});\r\n\r\n    } catch (error) {\r\n        return new Response(\r\n            500,\r\n            {},\r\n            {\r\n                error,\r\n            }\r\n        );\r\n    }\r\n};\r\n\r\n/**\r\n * This handler handles removing an address from user.\r\n * send DELETE Request at /api/user/address/:addressId\r\n *\r\n * */\r\n\r\nexport const removeAddressHandler = function (schema, request) {\r\n  const userId = requiresAuth.call(this, request);\r\n  try {\r\n    if (!userId) {\r\n      new Response(\r\n        404,\r\n        {},\r\n        {\r\n          errors: [\"The email you entered is not Registered. Not Found error\"],\r\n        }\r\n      );\r\n    }\r\n    let userAddresses = schema.users.findBy({ _id: userId }).address;\r\n    const addressId = request.params.addressId;\r\n    userAddresses = userAddresses.filter((item) => item._id !== addressId);\r\n    this.db.users.update({ _id: userId }, { address: userAddresses });\r\n    return new Response(200, {}, { address: userAddresses });\r\n  } catch (error) {\r\n    return new Response(\r\n      500,\r\n      {},\r\n      {\r\n        error,\r\n      }\r\n    );\r\n  }\r\n};"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,UAAU;AACnC,SAASC,UAAU,EAAEC,YAAY,QAAQ,oBAAoB;AAC7D,SAASC,EAAE,IAAIC,IAAI,QAAQ,MAAM;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,OAAO,MAAMC,sBAAsB,GAAG,SAAAA,CAAUC,MAAM,EAAEC,OAAO,EAAE;EAC/D,MAAMC,MAAM,GAAGN,YAAY,CAACO,IAAI,CAAC,IAAI,EAAEF,OAAO,CAAC;EAC/C,IAAI,CAACC,MAAM,EAAE;IACX,IAAIR,QAAQ,CACV,GAAG,EACH,CAAC,CAAC,EACF;MACEU,MAAM,EAAE,CAAC,0DAA0D;IACrE,CACF,CAAC;EACH;EACA,MAAMC,aAAa,GAAGL,MAAM,CAACM,KAAK,CAACC,MAAM,CAAC;IAAEC,GAAG,EAAEN;EAAO,CAAC,CAAC,CAACO,OAAO;EAClE,OAAO,IAAIf,QAAQ,CAAC,GAAG,EAAE,CAAC,CAAC,EAAE;IAAEe,OAAO,EAAEJ;EAAc,CAAC,CAAC;AAC1D,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMK,oBAAoB,GAAG,SAAAA,CAAUV,MAAM,EAAEC,OAAO,EAAE;EAC7D,MAAMC,MAAM,GAAGN,YAAY,CAACO,IAAI,CAAC,IAAI,EAAEF,OAAO,CAAC;EAC/C,IAAI;IACF,IAAI,CAACC,MAAM,EAAE;MACX,IAAIR,QAAQ,CACV,GAAG,EACH,CAAC,CAAC,EACF;QACEU,MAAM,EAAE,CAAC,0DAA0D;MACrE,CACF,CAAC;IACH;IACA,MAAMC,aAAa,GAAGL,MAAM,CAACM,KAAK,CAACC,MAAM,CAAC;MAAEC,GAAG,EAAEN;IAAO,CAAC,CAAC,CAACO,OAAO;IAClE,MAAM;MAAEA;IAAQ,CAAC,GAAGE,IAAI,CAACC,KAAK,CAACX,OAAO,CAACY,WAAW,CAAC;IAEnDR,aAAa,CAACS,IAAI,CAAC;MACjB,GAAGL,OAAO;MACVM,SAAS,EAAEpB,UAAU,CAAC,CAAC;MACvBqB,SAAS,EAAErB,UAAU,CAAC,CAAC;MACvBa,GAAG,EAAEV,IAAI,CAAC;IACZ,CAAC,CAAC;IACF,IAAI,CAACmB,EAAE,CAACX,KAAK,CAACY,MAAM,CAAC;MAAEV,GAAG,EAAEN;IAAO,CAAC,EAAE;MAAEO,OAAO,EAAEJ;IAAc,CAAC,CAAC;IACjE,OAAO,IAAIX,QAAQ,CAAC,GAAG,EAAE,CAAC,CAAC,EAAE;MAAEe,OAAO,EAAEJ;IAAc,CAAC,CAAC;EAC1D,CAAC,CAAC,OAAOc,KAAK,EAAE;IACd,OAAO,IAAIzB,QAAQ,CACjB,GAAG,EACH,CAAC,CAAC,EACF;MACEyB;IACF,CACF,CAAC;EACH;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMC,kBAAkB,GAAG,SAAAA,CAAUpB,MAAM,EAAEC,OAAO,EAAE;EAC3D,MAAMC,MAAM,GAAGN,YAAY,CAACO,IAAI,CAAC,IAAI,EAAEF,OAAO,CAAC;EAE7C,IAAI;IACA,IAAG,CAACC,MAAM,EAAC;MACP,IAAIR,QAAQ,CACR,GAAG,EACH,CAAC,CAAC,EACF;QACIU,MAAM,EAAE,CAAC,0DAA0D;MACvE,CACJ,CAAC;IACL;IAEA,MAAMiB,SAAS,GAAGpB,OAAO,CAACqB,MAAM,CAACD,SAAS;IAC1C,MAAM;MAACZ;IAAO,CAAC,GAAGE,IAAI,CAACC,KAAK,CAACX,OAAO,CAACY,WAAW,CAAC;IAEjD,IAAIR,aAAa,GAAGL,MAAM,CAACM,KAAK,CAACC,MAAM,CAAC;MAACC,GAAG,EAAEN;IAAM,CAAC,CAAC,CAACO,OAAO;IAE9DJ,aAAa,GAAIA,aAAa,CAACkB,GAAG,CAAEC,IAAI,IACpCA,IAAI,CAAChB,GAAG,KAAKa,SAAS,GAAGZ,OAAO,GAAGe,IACvC,CAAC;IAED,IAAI,CAACP,EAAE,CAACX,KAAK,CAACY,MAAM,CAAC;MAACV,GAAG,EAAEN;IAAM,CAAC,EAAE;MAACO,OAAO,EAAEJ;IAAa,CAAC,CAAC;IAC7D,OAAO,IAAIX,QAAQ,CAAC,GAAG,EAAE,CAAC,CAAC,EAAE;MAACe,OAAO,EAAEJ;IAAa,CAAC,CAAC;EAE1D,CAAC,CAAC,OAAOc,KAAK,EAAE;IACZ,OAAO,IAAIzB,QAAQ,CACf,GAAG,EACH,CAAC,CAAC,EACF;MACIyB;IACJ,CACJ,CAAC;EACL;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMM,oBAAoB,GAAG,SAAAA,CAAUzB,MAAM,EAAEC,OAAO,EAAE;EAC7D,MAAMC,MAAM,GAAGN,YAAY,CAACO,IAAI,CAAC,IAAI,EAAEF,OAAO,CAAC;EAC/C,IAAI;IACF,IAAI,CAACC,MAAM,EAAE;MACX,IAAIR,QAAQ,CACV,GAAG,EACH,CAAC,CAAC,EACF;QACEU,MAAM,EAAE,CAAC,0DAA0D;MACrE,CACF,CAAC;IACH;IACA,IAAIC,aAAa,GAAGL,MAAM,CAACM,KAAK,CAACC,MAAM,CAAC;MAAEC,GAAG,EAAEN;IAAO,CAAC,CAAC,CAACO,OAAO;IAChE,MAAMY,SAAS,GAAGpB,OAAO,CAACqB,MAAM,CAACD,SAAS;IAC1ChB,aAAa,GAAGA,aAAa,CAACqB,MAAM,CAAEF,IAAI,IAAKA,IAAI,CAAChB,GAAG,KAAKa,SAAS,CAAC;IACtE,IAAI,CAACJ,EAAE,CAACX,KAAK,CAACY,MAAM,CAAC;MAAEV,GAAG,EAAEN;IAAO,CAAC,EAAE;MAAEO,OAAO,EAAEJ;IAAc,CAAC,CAAC;IACjE,OAAO,IAAIX,QAAQ,CAAC,GAAG,EAAE,CAAC,CAAC,EAAE;MAAEe,OAAO,EAAEJ;IAAc,CAAC,CAAC;EAC1D,CAAC,CAAC,OAAOc,KAAK,EAAE;IACd,OAAO,IAAIzB,QAAQ,CACjB,GAAG,EACH,CAAC,CAAC,EACF;MACEyB;IACF,CACF,CAAC;EACH;AACF,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}